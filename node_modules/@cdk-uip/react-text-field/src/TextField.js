import React, { Component, Fragment } from "react";
import classnames from "classnames";
import {
  oneOfType,
  bool,
  element,
  func,
  node,
  number,
  string
} from "prop-types";
import { NotchedOutline } from "@cdk-uip/react-notched-outline";
import TextFieldPrefix from "./TextFieldPrefix";

class TextField extends Component {
  static propTypes = {
    /** The input value */
    value: oneOfType([string, number]),
    /** Called when the value is changed */
    onChange: func,
    /** The input type */
    type: string,
    /** The floating label text */
    label: node,
    /** Disable the text field */
    disabled: bool,
    /** For a more compact version */
    dense: bool,
    /** Full width text field */
    fullWidth: bool,
    /** Helper text to display below the text field */
    helperText: element,
    /** Enclose the text field in a box */
    box: bool,
    /** Leading icon element ("box" only) */
    leadingIcon: element,
    /** Trailing icon element ("box" only) */
    trailingIcon: element,
    /** Render as invalid */
    invalid: bool,
    /** Validation regex */
    pattern: string,
    /** Render as a box when the text field has focus */
    boxFocus: bool,
    /** Used to fetch a ref to the underlying input element */
    inputRef: func,
    /** Called when the underlying input receives focus */
    onFocus: func,
    /** Called when the underlying input loses focus */
    onBlur: func,
    /** Prefix. When applied the label will remain floated. */
    prefix: node,
    /** Enclose the text field in an outline */
    outlined: bool,
    /** Make the TextField readOnly */
    readOnly: bool
  };

  static defaultProps = {
    boxFocus: true,
    inputRef: () => {},
    onFocus: () => {},
    onBlur: () => {}
  };

  state = {
    hasFocus: false,
    isValid: true,
    prefixWidth: 0,
    labelWidth: 0
  };

  componentDidMount() {
    this.adjustInputPosition();
    this.getLabelWidth();
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.prefix !== prevProps.prefix ||
      this.state.hasFocus !== prevState.hasFocus
    ) {
      this.adjustInputPosition();
    }

    if (
      this.props.label !== prevProps.label ||
      this.props.dense !== prevProps.dense
    ) {
      this.getLabelWidth();
    }
  }

  adjustInputPosition() {
    if (this.prefix) {
      this.setState({ prefixWidth: this.prefix.offsetWidth });
    }
  }

  getLabelWidth() {
    if (this.label) {
      this.setState({
        labelWidth: this.label.offsetWidth * (this.props.dense ? 0.923 : 0.75)
      });
    }
  }

  onFocus = e => {
    this.setState({ hasFocus: true });
    this.props.onFocus(e);
  };

  onBlur = e => {
    this.setState({ hasFocus: false, isValid: e.target.validity.valid });
    this.props.onBlur(e);
  };

  onPrefixRef = ref => {
    this.prefix = ref;
  };

  render() {
    const {
      className,
      disabled,
      id,
      dense,
      fullWidth,
      value,
      label,
      helperText,
      box,
      leadingIcon,
      trailingIcon,
      invalid,
      readOnly,
      type,
      prefix,
      style,
      boxFocus,
      inputRef,
      onFocus,
      onBlur,
      outlined,
      ...other
    } = this.props;
    const { hasFocus, isValid, prefixWidth, labelWidth } = this.state;
    const shouldFloat = () =>
      value ||
      hasFocus ||
      type === "date" ||
      type === "time" ||
      type === "number";

    return (
      <Fragment>
        <label
          className={classnames(
            "mdc-text-field",
            "mdc-text-field--upgraded",
            {
              "mdc-text-field--focused": hasFocus,
              "mdc-text-field--invalid": invalid || !isValid,
              "mdc-text-field--read-only": readOnly || !isValid,
              "mdc-text-field--dense": dense,
              "mdc-text-field--with-leading-icon": leadingIcon,
              "mdc-text-field--with-trailing-icon": trailingIcon,
              "mdc-text-field--box": box,
              "mdc-text-field--block": fullWidth,
              "mdc-text-field--disabled": disabled,
              "mdc-text-field--box-focus": boxFocus,
              "mdc-text-field--outlined": outlined
            },
            className
          )}
        >
          {leadingIcon}

          {prefix &&
            shouldFloat() && (
              <TextFieldPrefix prefixRef={this.onPrefixRef}>
                {prefix}
              </TextFieldPrefix>
            )}
          <input
            className="mdc-text-field__input"
            type={type}
            disabled={disabled}
            readOnly={readOnly}
            value={value}
            id={id}
            onFocus={this.onFocus}
            onBlur={this.onBlur}
            style={{ ...style, paddingLeft: prefix && prefixWidth }}
            ref={inputRef}
            {...other}
          />

          {label && (
            <span
              className={classnames("mdc-floating-label", {
                "mdc-floating-label--float-above": shouldFloat(),
                "mdc-floating-label--shake":
                  !hasFocus && value && (invalid || !isValid)
              })}
              ref={ref => {
                this.label = ref;
              }}
            >
              {label}
            </span>
          )}

          {trailingIcon}

          {outlined && (
            <NotchedOutline
              open={shouldFloat() && !!label}
              width={labelWidth}
            />
          )}

          {!outlined && (
            <div
              className={classnames("mdc-line-ripple", {
                "mdc-line-ripple--active": hasFocus
              })}
            />
          )}
        </label>
        {helperText}
      </Fragment>
    );
  }
}

export default TextField;
