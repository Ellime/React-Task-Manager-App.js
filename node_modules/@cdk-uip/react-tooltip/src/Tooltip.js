import React from "react";
import PropTypes from "prop-types";
import classnames from "classnames";

const MIN_HORIZONTAL_MARGIN = 4;
const MIN_VERTICAL_MARGIN = 14;

/**
 * CDK Tooltip component.
 */
export default class Tooltip extends React.Component {
  static propTypes = {
    /** The id of the component that the tooltip is for. */
    htmlFor: PropTypes.string.isRequired,
    /** The tooltip label */
    children: PropTypes.node.isRequired
  };

  state = {
    show: false,
    active: false,
    deactive: false,
    top: "",
    left: "",
    right: ""
  };

  componentDidMount() {
    this.target = document.getElementById(this.props.htmlFor);
    if (this.target) {
      // Create events
      this.target.addEventListener("mouseenter", this.handleShow);
      this.target.addEventListener("mouseleave", this.handleHide);
      window.addEventListener("scroll", this.handleRemove);
    }
  }

  componentWillUnmount() {
    if (this.target) {
      // Remove events
      this.target.removeEventListener("mouseenter", this.handleShow);
      this.target.removeEventListener("mouseleave", this.handleHide);
      window.removeEventListener("scroll", this.handleRemove);
    }
  }

  handleShow = e => {
    const pos = this.adjustTooltipPosition();
    this.setState({
      show: true,
      active: true,
      deactive: false,
      ...pos
    });
  };

  handleHide = e => {
    this.setState({ active: false, deactive: true });
  };

  handleRemove = e => {
    this.setState({ show: false, active: false, deactive: false });
  };

  handleAnimationEnd = e => {
    if (e.animationName === "cdk-tooltip-exit-animation") {
      this.handleRemove(e);
    }
  };

  getTooltipSize() {
    const tooltipProps = this.tooltip.getBoundingClientRect();
    return {
      height: tooltipProps.bottom - tooltipProps.top,
      width: tooltipProps.right - tooltipProps.left
    };
  }

  adjustTooltipPosition() {
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;

    const tooltipSize = this.getTooltipSize();
    const referenceProps = this.target.getBoundingClientRect();
    const referenceWidth = referenceProps.right - referenceProps.left;
    const widthDifference = Math.abs(tooltipSize.width - referenceWidth);

    const position = {};

    // Vertical position
    if (
      referenceProps.bottom + tooltipSize.height + MIN_VERTICAL_MARGIN <
      viewportHeight
    ) {
      // show tooltip at bottom
      position.top = `${referenceProps.bottom + MIN_VERTICAL_MARGIN}px`;
    } else {
      // show tooltip at top
      position.top = `${referenceProps.top -
        tooltipSize.height -
        MIN_VERTICAL_MARGIN}px`;
    }

    // Horizontal position
    if (
      referenceProps.left + tooltipSize.width - widthDifference / 2 <
      viewportWidth
    ) {
      // adjust left property
      const left =
        referenceProps.left < widthDifference / 2
          ? 0
          : referenceProps.left - widthDifference / 2;
      const calculatedLeft =
        left < MIN_HORIZONTAL_MARGIN ? MIN_HORIZONTAL_MARGIN : left;
      position.left = `${calculatedLeft}px`;
    } else {
      // adjust right property
      position.right = `${MIN_HORIZONTAL_MARGIN}px`;
    }

    return position;
  }

  render() {
    const { htmlFor, className, children, ...other } = this.props;

    return (
      <span
        htmlFor={htmlFor}
        className={classnames(
          "cdk-tooltip",
          {
            "cdk-tooltip--show": this.state.show,
            "cdk-tooltip--is-active": this.state.active,
            "cdk-tooltip--is-deactive": this.state.deactive
          },
          className
        )}
        style={{
          top: this.state.top,
          left: this.state.left,
          right: this.state.right
        }}
        ref={tooltip => {
          this.tooltip = tooltip;
        }}
        onAnimationEnd={this.handleAnimationEnd}
        {...other}
      >
        {children}
      </span>
    );
  }
}
