'use strict';

// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'production';
process.env.NODE_ENV = 'production';

// Work around Bamboo not setting the CI variable
if (typeof process.env.bamboo !== 'undefined') {
  process.env.CI = true;
}

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
  throw err;
});

// Ensure environment variables are read.
require('../config/env');

const chalk = require('chalk');
const fs = require('fs-extra');
const webpack = require('webpack');
const globSync = require('glob').sync;
const mkdirpSync = require('mkdirp').sync;
const path = require('path');
const config = require('../config/webpack.config.intl');
const paths = require('../config/paths');
const formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');

const outputDir = paths.appLocales;
const defaultLocaleFile = path.join(outputDir, 'en.json');
const messagesDir = path.join(paths.appIntlTemp, 'messages');

// (Re-)Extract all messages
extract();

// Create the production build and print the deployment instructions.
function extract() {
  console.log('Extracting messages using webpack...');

  // Make sure the tmp folder is empty
  fs.emptyDirSync(paths.appIntlTemp);

  // Run webpack
  let compiler = webpack(config);
  compiler.run((err, stats) => {
    if (err) {
      throw err;
    }
    const messages = formatWebpackMessages(stats.toJson({}, true));
    if (messages.errors.length) {
      throw new Error(messages.errors.join('\n\n'));
    }

    // Aggregate all messages to produce a new default locale file
    aggregate();

    // Delete the tmp folder
    fs.removeSync(paths.appIntlTemp);

    console.log(chalk.green('Completed successfully.\n'));
  });
}

// Aggregates the default messages that were extracted from the example app's
// React components via the React Intl Babel plugin. An error will be thrown if
// there are messages in different components that use the same `id`. The result
// is a flat collection of `id: message` pairs for the app's default locale.
function aggregate() {
  console.log(
    "Aggregating all messages into '" + chalk.cyan(defaultLocaleFile) + "'..."
  );
  const filePattern = path.join(messagesDir, '**/*.json');

  // pick up @cdkglobal/* convention
  const libPattern = 'node_modules/@cdkglobal/*/i18n/messages/**/*.json';

  let defaultMessages = globSync(libPattern)
    .concat(globSync(filePattern))
    .map(filename => fs.readFileSync(filename, 'utf8'))
    .map(file => JSON.parse(file))
    .reduce(
      (collection, descriptors) => {
        descriptors.forEach(({ id, defaultMessage }) => {
          if (
            collection.hasOwnProperty(id) && collection[id] !== defaultMessage
          ) {
            throw new Error(
              `Duplicate message id: ${id} with different defaultMessage ('${collection[id]}' vs '${defaultMessage}')`
            );
          }
          collection[id] = defaultMessage;
        });

        return collection;
      },
      {}
    );
  // Create a new directory that we want to write the aggregate messages to
  mkdirpSync(outputDir);

  // Delete the old default locale file
  fs.removeSync(defaultLocaleFile);

  // Write the messages to this directory
  fs.writeFileSync(defaultLocaleFile, JSON.stringify(defaultMessages, null, 2));
}
