import { v4 as uuid } from "uuid";

// Map of status codes -> errors
let statusCodes = {};

// URL Routing
let mappedRoutes = {};

let defaultOptions = {};

const checkStatus = response => {
  if (response.status >= 200 && response.status < 300) {
    return response;
  } else {
    // attempt to parse the response
    return parseResponse(response).then(
      payload => {
        if (statusCodes[response.status]) {
          // this is now a "friendly" error, do not include detail
          throw new Error(statusCodes[response.status]);
        }
        const error = new Error(
          payload.message || payload.msg || response.statusText
        );
        error.response = response;
        error.payload = payload;
        throw error;
      },
      () => {
        if (statusCodes[response.status]) {
          throw new Error(statusCodes[response.status]);
        }
        const error = new Error(response.statusText);
        error.response = response;
        throw error;
      }
    );
  }
};

const parseResponse = response => {
  const contentType = response.headers.get("content-type");
  if (contentType && contentType.indexOf("application/json") > -1) {
    return response.json();
  }
  return response.text();
};

const setDefaultOptions = options => {
  defaultOptions = { ...defaultOptions, ...options };
};

const clearDefaultOptions = () => {
  defaultOptions = {};
};

const exec = (url, options) => {
  options = {
    credentials: "same-origin",
    ...defaultOptions,
    ...options
  };
  const requestUrl = formatUrl(url);
  const p = fetch(requestUrl, options)
    .then(checkStatus)
    .then(parseResponse);
  p.catch(error => {
    console.error(`Request failed '${requestUrl}'`, error);
  });
  return p;
};

export const buildQueryString = options => {
  // apply the default options
  options = {
    query: {},
    startBy: "?",
    splitBy: "&",
    ...options
  };
  let query = "";
  for (let prop in options.query) {
    if (!prop || !options.query.hasOwnProperty(prop)) {
      continue;
    }
    if (typeof prop === "object") {
      // do not attempt to send complex context objects
      continue;
    }
    if (!options.query[prop]) {
      // skip anything falsey (even 0)
      continue;
    }
    const item =
      encodeURIComponent(prop) + "=" + encodeURIComponent(options.query[prop]);
    if (query) {
      query += options.splitBy + item;
    } else {
      query = item;
    }
  }
  return query ? options.startBy + query : "";
};

const applyRouting = url => {
  for (let key in mappedRoutes) {
    const regex = new RegExp("^" + key);
    if (regex.test(url)) {
      return url.replace(regex, mappedRoutes[key]);
    }
  }
  return url;
};

export const formatUrl = spec => {
  // allow a plain string
  spec = typeof spec === "string" ? { baseUrl: spec } : spec;
  // options object
  let url = applyRouting(spec.baseUrl);
  url += buildQueryString({
    query: spec.query
  });
  return url;
};

const addCorrelationId = (headers = {}) => {
  return {
    correlationId: uuid(),
    ...headers
  };
};

export const get = ({ url, headers = {} }) => {
  return exec(url, {
    method: "GET",
    headers: addCorrelationId({
      Accept: "application/json",
      ...headers
    })
  });
};

export const put = ({ url, data, headers = {} }) => {
  return exec(url, {
    method: "PUT",
    headers: addCorrelationId({
      Accept: "application/json",
      "Content-Type": "application/json;charset=UTF-8",
      ...headers
    }),
    body: JSON.stringify(data)
  });
};

export const patch = ({ url, data, headers = {} }) => {
  return exec(url, {
    method: "PATCH",
    headers: addCorrelationId({
      Accept: "application/json",
      "Content-Type": "application/json;charset=UTF-8",
      ...headers
    }),
    body: JSON.stringify(data)
  });
};

export const post = ({ url, data, headers = {} }) => {
  return exec(url, {
    method: "POST",
    headers: addCorrelationId({
      Accept: "application/json",
      "Content-Type": "application/json;charset=UTF-8",
      ...headers
    }),
    body: JSON.stringify(data)
  });
};

export const _delete = ({ url, headers = {} }) => {
  return exec(url, {
    method: "DELETE",
    headers: addCorrelationId({
      Accept: "application/json",
      ...headers
    })
  });
};

export const registerStatusCodes = codes => {
  statusCodes = { statusCodes, ...codes };
};

export const clearStatusCodes = () => {
  statusCodes = {};
};

export const registerRoutes = routes => {
  mappedRoutes = { mappedRoutes, ...routes };
};

export const clearRoutes = () => {
  mappedRoutes = {};
};

// new API
export default {
  get,
  put,
  patch,
  post,
  delete: _delete,
  registerStatusCodes,
  clearStatusCodes,
  registerRoutes,
  clearRoutes,
  buildQueryString,
  formatUrl,
  setDefaultOptions,
  clearDefaultOptions
};
