import http from "./index";

test("should build a query string", function() {
  expect(http.buildQueryString({})).toBe("");
  expect(
    http.buildQueryString({
      query: {
        x: "y"
      }
    })
  ).toBe("?x=y");
  expect(
    http.buildQueryString({
      query: {
        x: "y",
        a: "b"
      }
    })
  ).toBe("?x=y&a=b");
  expect(
    http.buildQueryString({
      query: {
        x: "y",
        a: "b"
      },
      startBy: ";",
      splitBy: ","
    })
  ).toBe(";x=y,a=b");
  expect(
    http.buildQueryString({
      query: {
        x: undefined
      }
    })
  ).toBe("");
  expect(
    http.buildQueryString({
      query: {
        x: null
      }
    })
  ).toBe("");
  expect(
    http.buildQueryString({
      query: {
        x: ""
      }
    })
  ).toBe("");
  expect(
    http.buildQueryString({
      query: {
        x: 0
      }
    })
  ).toBe("");
});

beforeAll(() => {
  // Mock out console.error to remove clutter
  // from the test output
  global.console.error = jest.fn();
  // Clear any status codes so tests will run in
  // any order
  http.clearStatusCodes();
});

describe("checkStatus", () => {
  it("handles a 200 responses", () => {
    global.fetch = jest.fn().mockImplementationOnce(() =>
      Promise.resolve({
        status: 200,
        headers: new Headers(),
        text: () => Promise.resolve("OK")
      })
    );
    return http.get({ url: "/api/fake" }).then(response => {
      expect(response).toBe("OK");
    });
  });

  const mockFetch = json => {
    global.fetch = jest.fn().mockImplementationOnce(() =>
      Promise.resolve({
        status: 401,
        statusText: "Default 401 message",
        headers: new Headers({
          "content-type": "application/json"
        }),
        json: () => Promise.resolve(json)
      })
    );
  };

  it("handles errors with a message payload", () => {
    mockFetch({
      message: "401 error"
    });
    return http.get({ url: "/api/fake" }).catch(e => {
      expect(e.message).toBe("401 error");
    });
  });

  it("handles errors with a msg payload", () => {
    mockFetch({
      msg: "401 error"
    });
    return http.get({ url: "/api/fake" }).catch(e => {
      expect(e.message).toBe("401 error");
    });
  });

  it("handles errors with no error message in the payload", () => {
    mockFetch({});
    return http.get({ url: "/api/fake" }).catch(e => {
      expect(e.message).toBe("Default 401 message");
    });
  });
});

describe("registerStatusCodes", () => {
  it("uses a custom message", () => {
    // Mock the fetch to return a simple text error
    global.fetch = jest.fn().mockImplementationOnce(() =>
      Promise.resolve({
        status: 401,
        headers: new Headers(),
        text: () => Promise.resolve("401 error")
      })
    );

    http.registerStatusCodes({
      401: "Please login first"
    });

    return http.get({ url: "/api/fake" }).catch(e => {
      expect(e.message).toBe("Please login first");
    });
  });

  it("uses a custom message when parseResponse fails", () => {
    // Mock the fetch to fail when response.text() is called
    global.fetch = jest.fn().mockImplementationOnce(() =>
      Promise.resolve({
        status: 401,
        headers: new Headers(),
        text: () => Promise.reject()
      })
    );

    http.registerStatusCodes({
      401: "Please login first"
    });

    return http.get({ url: "/api/fake" }).catch(e => {
      expect(e.message).toBe("Please login first");
    });
  });
});

describe("should have correlation ID", () => {
  const request = cb => {
    global.fetch = jest.fn().mockImplementationOnce((url, options) => {
      expect(options.headers["correlationId"]).toBeTruthy();
      return Promise.resolve({
        status: 200,
        headers: new Headers(),
        text: () => Promise.resolve()
      });
    });
    return cb();
  };

  it("handles GET", () => request(() => http.get({ url: "/api/fake" })));
  it("handles PUT", () => request(() => http.put({ url: "/api/fake" })));
  it("handles PATCH", () => request(() => http.patch({ url: "/api/fake" })));
  it("handles POST", () => request(() => http.post({ url: "/api/fake" })));
  it("handles DELETE", () => request(() => http.delete({ url: "/api/fake" })));
});

describe("should consider additional headers sent with the api request", () => {
  const expectAuthorizationHeaderValue = "Bearer token-id";
  const apiRequestHeaders = {
    Authorization: expectAuthorizationHeaderValue
  };

  const request = cb => {
    global.fetch = jest.fn().mockImplementationOnce((url, options) => {
      expect(options.headers["correlationId"]).toBeTruthy();
      expect(options.headers["Authorization"]).toBe(
        expectAuthorizationHeaderValue
      );
      return Promise.resolve({
        status: 200,
        headers: new Headers(),
        text: () => Promise.resolve()
      });
    });
    return cb();
  };

  it("handles GET", () =>
    request(() => http.get({ url: "/api/fake", headers: apiRequestHeaders })));
  it("handles PUT", () =>
    request(() => http.put({ url: "/api/fake", headers: apiRequestHeaders })));
  it("handles PATCH", () =>
    request(() =>
      http.patch({ url: "/api/fake", headers: apiRequestHeaders })
    ));
  it("handles POST", () =>
    request(() => http.post({ url: "/api/fake", headers: apiRequestHeaders })));
  it("handles DELETE", () =>
    request(() =>
      http.delete({ url: "/api/fake", headers: apiRequestHeaders })
    ));
});

describe("should handle routing", () => {
  beforeEach(() => {
    http.clearRoutes();
  });

  it("handles no mapped route", () => {
    expect(http.formatUrl("/api/org/v1/users/self")).toBe(
      "/api/org/v1/users/self"
    );
  });

  it("handles mapped route", () => {
    http.registerRoutes({
      "/api/org/": "/api/ari-gp-organization/"
    });
    expect(http.formatUrl("/api/survey/v1/surveys")).toBe(
      "/api/survey/v1/surveys"
    );
    expect(http.formatUrl("/api/org/v1/users/self")).toBe(
      "/api/ari-gp-organization/v1/users/self"
    );
  });

  it("handles 2 mapped routes", () => {
    http.registerRoutes({
      "/api/org/": "/api/ari-gp-organization/",
      "/api/survey/": "/api/ari-gp-survey/"
    });
    expect(http.formatUrl("/api/survey/v1/surveys")).toBe(
      "/api/ari-gp-survey/v1/surveys"
    );
    expect(http.formatUrl("/api/org/v1/users/self")).toBe(
      "/api/ari-gp-organization/v1/users/self"
    );
  });
});

describe("should handle default options", () => {
  beforeEach(() => {
    http.clearDefaultOptions();
  });

  it("handles default option", () => {
    global.fetch = jest.fn().mockImplementationOnce((url, options) => {
      expect(options.test).toBe("test");
      return Promise.resolve({
        status: 200,
        headers: new Headers(),
        text: () => ""
      });
    });

    http.setDefaultOptions({
      test: "test"
    });

    return http.get({ url: "" });
  });

  it("handles default option override", () => {
    global.fetch = jest.fn().mockImplementationOnce((url, options) => {
      expect(options.method).toBe("GET");
      return Promise.resolve({
        status: 200,
        headers: new Headers(),
        text: () => ""
      });
    });

    http.setDefaultOptions({
      method: "TEST"
    });

    return http.get({ url: "" });
  });

  it("handles credentials override", () => {
    global.fetch = jest.fn().mockImplementationOnce((url, options) => {
      expect(options.credentials).toBe("include");
      return Promise.resolve({
        status: 200,
        headers: new Headers(),
        text: () => ""
      });
    });

    http.setDefaultOptions({
      credentials: "include"
    });

    return http.get({ url: "" });
  });
});
